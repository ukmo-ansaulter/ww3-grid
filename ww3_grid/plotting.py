import os
import numpy as np
import numpy.ma as ma
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
from matplotlib.patches import Circle
from matplotlib.path import Path # Path is much faster than Shapely
from matplotlib.collections import PolyCollection, PatchCollection
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

import cartopy.crs as ccrs
import cartopy.feature as cfeature

import cmocean

###############################################################
# -- Class UnSMC
class UnSMC(object):
    """
    UnSMC [Unstructured SMC grid/cell]

    For simplicity, we only get SMC cells from a specific file, which is
    arranged as follows:
        NL N1 N2 N4 N8
        i j xsize ysize depth [sx, sy, wave parms]

    Input args:
    -----------
        fnm -- filename/path of smcCell

        dlon & dlat -- resolution of size-1 cell [transform points]

        refp -- refp point

        proj -- cartopy projection
                for global smc grid, please do not use the arg
    """
    def __init__(self, fnm, dlon=None, dlat=None, refp=None, proj=None):
        # -- header
        with open(fnm) as f:
            header = np.array(f.readline().strip().split()).astype('l')
            #(self.NL, self.N1, self.N2, self.N4) = header
            if len(header) == 5:
                (self.NL, self.N1, self.N2, self.N4, self.N8) = header
            if len(header) == 6:
                (self.NL, self.N1, self.N2, self.N4, self.N8, self.N16) = header

        # -- contents
        smc_df = pd.read_csv(fnm, sep='\s+', skiprows=1, dtype=np.int64,
                             names=['i', 'j', 'xsize', 'ysize', 'depth'])

        # -- assign each column to self
        for name in smc_df.columns:
            setattr(self, name, smc_df[name])

        # -- dlon & dlat & gid
        self.dlon, self.dlat = dlon, dlat
        self.gid = os.path.splitext(os.path.basename(fnm))[0]
        self.refp = refp
        self.proj = proj

    def _genPoly(self):
        """
        Generate PolyCollection for further plotting.
            xvert, yvert, clat, clon --> poly vertices
        """
        rx, ry = self.refp

        # -- sw corner lat/lon
        self.sw_lon = self.i * self.dlon + rx
        self.sw_lat = self.j * self.dlat + ry

        # -- center lon/lat
        self.clon = self.sw_lon + self.xsize * self.dlon * 0.5
        self.clat = self.sw_lat + self.ysize * self.dlat * 0.5

        # -- edges [nl * 4]
        xvert = np.c_[self.sw_lon, self.sw_lon+self.xsize*self.dlon,
                      self.sw_lon+self.xsize*self.dlon, self.sw_lon,]

        yvert = np.c_[self.sw_lat, self.sw_lat, self.sw_lat+self.ysize*self.dlat,
                      self.sw_lat+self.ysize*self.dlat]

        self.poly = np.zeros((self.NL, 4, 2)) # nl * 4 * 2
        self.poly[:, :, 0] = xvert # longitude
        self.poly[:, :, 1] = yvert # latitude

        # -- seems not necessary
        # -- transform lon/lat to map
        # -- although PolyCollection accepts a keyword `transform`, we
        # -- undertake the transformation explicitly for performance
        if self.proj is not None:
            points1d = self.poly.ravel()
            # -- points_map [npntsx3]
            points_map = self.proj.transform_points(ccrs.PlateCarree(),
                                                    points1d[0::2], # x
                                                    points1d[1::2]) # y
            self.poly[..., 0] = points_map[:, 0].reshape(self.NL, 4)
            self.poly[..., 1] = points_map[:, 1].reshape(self.NL, 4)

    def readVar(self, fnm, var=None):
        """
        readVar

        Add other var (like wave parameters) from fnm [generated by propagating
        test]
        """
        with open(fnm) as f:
            self.time, nc = np.array(f.readline().strip().split(), dtype='l')
            assert nc == self.NL, 'readVar: No. of Cells does not match'

            beg = 0
            vararr = np.empty(nc, dtype='d')
            conts = f.readlines()
            for line in conts:
                lnstr = line.strip().split()
                nelm = len(lnstr)
                if nelm == 0: continue

                vararr[beg: beg+nelm] = np.array(lnstr).astype('d')

                beg = beg+nelm

        setattr(self, var, pd.Series(vararr, index=self.i.index))

    def readObs(self, fnm):
        """
        readObs

        Read obstruction file
        """
        with open(fnm) as f:
            header = f.readline().strip().split()
            nc = long(header[0])
            assert nc == self.NL, 'readObs: No. of Cells does not match'

        arr = np.loadtxt(fnm, skiprows=1)
        self.sx = pd.Series(arr[:, 0], index=self.i.index)
        self.sy = pd.Series(arr[:, 1], index=self.i.index)

    def genPlot(self, ax=None, filled=False, plot_var=None, cax_kws=None,
            cb_kws=None, txtloc=None, center=False, dotsize=0.008, mapext=None,
            vmin=None, vmax=None, vint=None, txtSize=7, cbtxtSize=None,
            linewidth=0.1):
        """
        Generate plot for plot_var on SMC grid

        Args:
            ax (object):            axis object
            filled (bool):          fill cells or not
            plot_var (str):         the parameter need to be plotted, of which valules
                                    determine the filled color
            cax_kws (dict):         kws for colorbar location
            cb_kwds (dict):         kws for colobar
            txtloc (str):           loc of necessary text info. (x, y)
            center (bool):          draw dots in each cell
            dotsize (int):          the radius of Circles (for cell center dots)
            mapext  (list):         map bbox to zoom in the cartopy map
            vmin/vmax/vint (float): colorbar range/tick
        """
        if not hasattr(self, 'poly'):
            self._genPoly()

        # -- plot setting
        if plot_var.lower() == 'depth':
            norm = mpl.colors.LogNorm(vmin=1, vmax=10000, clip=False)
            cmap = cmocean.cm.deep
            cbtl = 'Depth [m]'
            cticks = [1, 10, 100, 1000, 10000]

        elif plot_var.lower() == 'swh':
            if vmin is None: vmin = 0.
            if vmax is None: vmax = 6.
            if vint is None: vint = 1.
            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax, clip=False)
            cmap = plt.get_cmap('viridis')
            cbtl = 'SWH [m]'
            cticks = np.arange(vmin, vmax+.1*vint, vint)

        elif plot_var.lower() == 'sx' or plot_var.lower() == 'sy':
            filled = True
            norm = mpl.colors.Normalize(vmin=0., vmax=100., clip=False)
            cmap = plt.get_cmap('viridis')
            cbtl = 'Obs. in {:s} dirc. [%]'.format(plot_var.lower()[1])
            cticks = np.arange(0, 101, 20)

        elif plot_var.lower() == 'wspd':
            vmax = vmax if vmax else 40
            vmin = vmin if vmin else 0.
            vint = vint if vint else 10.
            cmap = plt.get_cmap('plasma')
            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax, clip=False)
            cbtl = 'Wind [m/s]'
            cticks = np.arange(vmin, vmax+.1*vint, vint)

        else:
            pass

        facecolor = None if filled else 'none'

        # -- cells
        if self.proj is not None:
            polyc = PolyCollection(self.poly, cmap=cmap, norm=norm,
                    linewidth=linewidth, facecolor=facecolor)
        else:
            polyc = PolyCollection(self.poly, cmap=cmap, norm=norm,
                    linewidth=linewidth, facecolor=facecolor,
                    transform=ccrs.PlateCarree())
        polyc.set_edgecolor('face')
        polyc.set_array(ma.masked_equal(getattr(self, plot_var), -999999))
        ax.add_collection(polyc)

        # -- center dot of each cell
        # -- use 'o' or 's' to replace '.'
        if center: # use very small size for scatter/marker
            ax.scatter(self.clon, self.clat, s=dotsize, c=getattr(self,
                plot_var), marker='o', norm=norm, cmap=cmap,
                transform=ccrs.PlateCarree())

#            circlec = PatchCollection([Circle((x, y), radius=radius)
#                                       for x, y in np.c_[self.clon, self.clat]],
#                                      edgecolor='none', cmap=cmap, norm=norm,
#                                      transform=ccrs.PlateCarree())
#            circlec.set_array(getattr(self, plot_var))
#            ax.add_collection(circlec)

        # -- lim axis
        ax.autoscale_view() # !!! Very important

        if mapext is not None:
            ax.set_extent(mapext, crs=ccrs.PlateCarree())

        # -- colorbar
        if cax_kws is None: cax_kws = dict()
        btr = None if cax_kws.get('bbox_to_anchor') is None else ax.transAxes

        cax = inset_axes(ax,
                         width=cax_kws.get('width', '40%'),
                         height=cax_kws.get('height', '3%'),
                         loc=cax_kws.get('loc', 2), # upper right
                         bbox_to_anchor=cax_kws.get('bbox_to_anchor', None),
                         bbox_transform=btr,
                         borderpad=cax_kws.get('borderpad', None))  # units: fontsize
                         #borderpad=cax_kws.get('borderpad', 2.))  # units: fontsize

        # This is causing a crash for some reason...
        if cb_kws is None: cb_kws=dict()
        cb = plt.colorbar(polyc, cax=cax, format='%d',
                          orientation=cb_kws.get('orientation', 'horizontal'))
        cb.set_label(cbtl, size=txtSize)
        cb.set_ticks(cticks)
        if cbtxtSize is None: cbtxtSize = txtSize - 1
        cb.ax.tick_params(labelsize=cbtxtSize)

        # -- cell info.
        if plot_var in ['depth', 'sx', 'sy']:
            info = ('{:s}\n'
                    r'$\longmapsto$'
                    '\n  NL = {:d}\n  N1 = {:d}\n  N2 = {:d}\n  N4 = {:d}').format(
                    self.gid, self.NL, self.N1, self.N2, self.N4)

        if plot_var in ['swh', 'wspd']:
            try:
                timeStr = self.time.strftime('%Y-%m-%d %HZ')
            except:
                timeStr = str(self.time)

            info = '{:s}\n    Max: {:.1f}\n    Min: {:.1f}'.format(
                    timeStr, getattr(self, plot_var).max(), getattr(self, plot_var).min())

        if txtloc is None: txtloc = (0.1, 0.85)
        ax.text(txtloc[0], txtloc[1], info, ha='left',
                va='top', multialignment='left', transform=ax.transAxes,
                fontsize=txtSize, color='k')

###############################################################
# -- CartopyMap
def CartopyMap(proj=ccrs.Robinson(central_longitude=180.), resolution='50m', gridbase=10, land=False,
               coast=True, nrows=1, ncols=1, **fig_kw):
    """
    Create a map by Cartopy

    set_extent does not work for lambert projection

    Input args:
    -----------
        proj -- one specific projection supported by Cartopy

        resolution -- the resolution of coastline, `100m`, `50m` or `10m`

        fig -- figure object

        gridbase -- draw gridlines on multiple*gridbase

        land -- fill land or not

        coast -- draw coastline or not
    """
    fig, axs = plt.subplots(nrows=nrows, ncols=ncols,
                            subplot_kw=dict(projection=proj), **fig_kw)

    if nrows * ncols == 1: axs = np.array([axs,])

    # -- fill land & coastline
    if land:
        LAND = cfeature.NaturalEarthFeature('physical', 'land', resolution,
                                            edgecolor='face',
                                            facecolor=cfeature.COLORS['land'])
        for ax in axs:
            ax.add_feature(LAND, facecolor='.75')

    if coast:
        for ax in axs:
            ax.coastlines(resolution, linewidth=.5)

    # -- gridlines
    for ax in axs:
        gl = ax.gridlines(color='.5', linewidth=0.4, linestyle='-')
        gl.xlocator = mticker.MultipleLocator(gridbase)
        gl.ylocator = mticker.MultipleLocator(gridbase)

    if nrows * ncols == 1: axs = axs[0]

    return fig, axs



# -- WW3SMC
class WW3SMC(UnSMC):
    def __init__(self, cellFnm=None, dlon=None, dlat=None, refp=None):
        super(WW3SMC, self).__init__(fnm=cellFnm, dlon=dlon, dlat=dlat, refp=refp)

    def readWW3(self, ww3Fnm):
        """
        Read ww3Fnm

        To do [support more components]
        """
        # -- header [time, sclFac, var]
        with open(ww3Fnm) as f:
            print('**** Reading {:s} ****'.format(ww3Fnm))
            header = f.readline().strip().split()
            self.time = datetime.datetime.strptime(header[2] + header[3],
                                                   '%Y%m%d%H%M%S')
            ncel = int(header[4])
            ndim = int(header[5])
            sclFac = float(header[6])
            fext = header[7]

            assert ncel == self.NL, ('# of sea points do not agree with the'
                                     ' bathy file')

            varArr = np.zeros(self.NL*ndim, dtype='d')

            beg = 0
            conts = f.readlines()
            for line in conts:
                lnstr = line.strip().split()
                nelm = len(lnstr)
                if nelm == 0: continue

                varArr[beg: beg+nelm] = np.array(lnstr).astype('d')
                beg = beg+nelm

#            varArr *= sclFac
        if ndim > 1:
            varArr = np.reshape(varArr, (ndim, self.NL))

        if fext == '.hs':
            self.swh = varArr
        elif fext == '.wnd':
            self.u10 = varArr[0]
            self.v10 = varArr[1]
            self.wspd = np.sqrt(self.u10**2. + self.v10**2.)

        del varArr

###############################################################
